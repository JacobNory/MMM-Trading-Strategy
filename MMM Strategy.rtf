//@version=5
strategy("MMM Strategy", overlay = true,
         default_qty_type = strategy.percent_of_equity, default_qty_value = 10)

// ══════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════
lenHL   = input.int  (50 , "High/Low look-back"   , minval = 1)
lenMA   = input.int  (50 , "MEAN-MA look-back"    , minval = 1)
bins    = input.int  (20 , "Mode bins"            , minval = 2)
sdMult  = input.float(2  , "Std-Dev multiplier"   , minval = 0.1, step = 0.1)

hBars   = input.int  (60 , "Hit-probability horizon (bars)", minval = 1)  // ← NEW LINE

basisOpt = input.string("Close" , "Price basis" , options = ["Close","HighLow"])
mktType  = input.string("Stocks", "Market type" , options = ["Stocks","Futures"])

// input values **must** be literal → use a neutral default (0.25)
// then derive the effective increment below
userInc = input.float(0.25, "Price increment", minval = 0.01, step = 0.01)

// choose the increment that will actually be used
incStockDef   = 0.25
incFuturesDef = 5.0
effectiveInc  = mktType == "Stocks" ? userInc : (userInc < 0.01 ? incFuturesDef : userInc)

// ══════════════════════════════════════════════════════════════════
// SERIES PREP
// ══════════════════════════════════════════════════════════════════
src   = basisOpt == "Close" ? close : hl2
hi    = ta.highest(high, lenHL)
lo    = ta.lowest (low , lenHL)
midHL = (hi + lo) * 0.5

mean  = ta.sma(src,    lenMA)          // MEAN-MA
med   = ta.median(src, lenMA)

// ── helper clamp (Pine has no math.clamp)
f_clamp(_x, _lo, _hi) => _x < _lo ? _lo : _x > _hi ? _hi : _x

// ── MODE via simple histogram
f_mode(_s, _len, _bins) =>
    lo_ = ta.lowest (_s, _len)
    hi_ = ta.highest(_s, _len)
    rng = hi_ - lo_
    if rng == 0               // flat range guard
        _s
    else
        step = rng / _bins
        hist = array.new_int(_bins, 0)
        for i = 0 to _len - 1
            idx = f_clamp(int(math.floor((_s[i] - lo_) / step)), 0, _bins - 1)
            array.set(hist, idx, array.get(hist, idx) + 1)
        // manual arg-max
        maxBin = 0
        maxCnt = array.get(hist, 0)
        for j = 1 to _bins - 1
            cnt = array.get(hist, j)
            if cnt > maxCnt
                maxCnt := cnt
                maxBin := j
        lo_ + (maxBin + 0.5) * step

mode = f_mode(src, lenMA, bins)

// Deviation bands
stDev = ta.stdev(src, lenMA)
stDev := na(stDev) or stDev <= 0 ? 0.01 : stDev   // safety floor
upper = mean + stDev * sdMult
lower = mean - stDev * sdMult
outlier = src > upper or src < lower

// Trend & volume context
trendUp = mean > mean[1]

// Suggested values if manual inputs are not provided
suggestEntry  = src
suggestTarget = trendUp ? upper : lower
suggestStop   = trendUp ? lower - stDev : upper + stDev

// ── explicit volume sums ──
float bullVol = 0.0          // running bullish volume (float)
float bearVol = 0.0          // running bearish volume (float)

for i = 0 to lenMA - 1
    vol_i   = volume[i]
    bullVol += close[i] > open[i] ? vol_i : 0.0
    bearVol += close[i] < open[i] ? vol_i : 0.0

volBull = bullVol > bearVol   // true when buyers dominate

// Manual input fields
manualEntry = input.float(0.0, "Manual Entry Price", step = 0.01)
manualStop   = input.float(0.0, "Manual Stop-Loss", step = 0.01)
manualTarget = input.float(0.0, "Manual Profit", step = 0.01)

// Final entry/stop/target (manual OR auto) + R:R + success forecast
entryPrice  = manualEntry == 0.0  ? suggestEntry  : manualEntry
stopPrice   = manualStop  == 0.0  ? suggestStop   : manualStop
targetPrice = manualTarget == 0.0 ? suggestTarget : manualTarget

// distances & ratio
riskDist   = math.abs(entryPrice - stopPrice)
rewardDist = math.abs(targetPrice - entryPrice)
rrRatio    = rewardDist / riskDist

// ════════════════════════════════
// TRADE-PLAN SUPPORT FUNCTIONS
// ════════════════════════════════
// Cumulative probability that price will hit _target before _stop
f_cumeProb(_lvls, _prbs, _entry, _target, _stop) =>
    float acc = 0.0
    for i = 0 to array.size(_lvls) - 1
        lvl = array.get(_lvls, i)
        p   = array.get(_prbs, i)
        // Check if level is between entry and target (excluding stop)
        inTargetRange = _target > _entry ? (lvl <= _target and lvl >= _entry) : (lvl >= _target and lvl <= _entry)
        inStopZone    = _stop   > _entry ? (lvl <= _stop   and lvl >= _entry) : (lvl >= _stop   and lvl <= _entry)
        if inTargetRange and not inStopZone
            acc += p
    acc

// ════════════════════════════════
// BUILD & RANK LEVELS
// ════════════════════════════════
// ════════════════════════════════
// BUILD & RANK LEVELS  (horizon-aware, one-sided ranking)
// ════════════════════════════════
var float[] lvls    = array.new_float(0)
var float[] weights = array.new_float(0)
array.clear(lvls)
array.clear(weights)

// 10 steps up / 10 steps down from current price
for k = 1 to 16
    array.push(lvls, src + k * effectiveInc)
    array.push(lvls, src - k * effectiveInc)

// ――― context flags & constants ―――
biasStrength = 0.85   // directional tilt (range 0 – 1)
kDamping     = 0.08   // distance-damping coefficient
bullCtx      = trendUp and volBull
bearCtx      = (not trendUp) and (not volBull)

// σ adapted to the chosen forecast horizon
sigmaH = stDev * math.sqrt(hBars / lenMA)

// Normal-CDF tail probability
f_norm(_z) =>
    z = f_clamp(_z, -10.0, 10.0)
    a1 = 0.254829592, a2=-0.284496736, a3=1.421413741
    a4 = -1.453152027, a5=1.061405429, p=0.3275911
    sign = z < 0 ? -1 : 1
    x = math.abs(z)/math.sqrt(2)
    t = 1/(1+p*x)
    y = 1 - (((((a5*t + a4)*t + a3)*t + a2)*t + a1)*t) * math.exp(-x*x)
    0.5*(1+sign*y)
// helper — probability of touching _lvl within the hBars horizon
f_probHit(_lvl, _cur, _sigH) =>
    z = (_lvl - _cur) / _sigH
    _lvl > _cur ? 1 - f_norm(z) : f_norm(z)

// helper ― composite weight
f_weight(_lvl, _cur, _sigH, _fav, _k, _beta) =>
    tail   = f_probHit(_lvl, _cur, _sigH)                       // hit-probability
    dist   = math.exp(-_k * math.abs(_lvl - _cur) / effectiveInc) // distance damping
    dirAdj = _fav ? (1 + _beta) : (1 - _beta)                   // directional tilt
    tail * dist * dirAdj

// ――― score every candidate level ―――
float totalW = 0.0
for i = 0 to array.size(lvls) - 1
    lvl = array.get(lvls, i)
    fav = (lvl > src and bullCtx) or (lvl < src and bearCtx)
    w   = f_weight(lvl, src, sigmaH, fav, kDamping, biasStrength)
    array.push(weights, w)
    totalW += w

// normalise to 0-100 %
totalW := totalW == 0 ? 1 : totalW
for i = 0 to array.size(weights) - 1
    array.set(weights, i, array.get(weights, i) / totalW * 100)

// ――― selection-sort weights ↓ high→low ―――
float[] lCopy = array.copy(lvls)
float[] wCopy = array.copy(weights)

for i = 0 to array.size(wCopy) - 2
    maxIdx = i
    maxVal = array.get(wCopy, i)
    for j = i + 1 to array.size(wCopy) - 1
        if array.get(wCopy, j) > maxVal
            maxIdx := j
            maxVal := array.get(wCopy, j)
    if maxIdx != i
        tmpW = array.get(wCopy, i)
        tmpL = array.get(lCopy, i)
        array.set(wCopy, i, array.get(wCopy, maxIdx))
        array.set(lCopy, i, array.get(lCopy, maxIdx))
        array.set(wCopy, maxIdx, tmpW)
        array.set(lCopy, maxIdx, tmpL)

// ───── keep first 10  +  capture *absolute* hit-probabilities ─────
float[] topLvls   = array.new_float(0)
float[] topPrbs   = array.new_float(0)   // share-of-mass weights (rank %)
float[] absProbs  = array.new_float(0)   // NEW: absolute hit probability %

for i = 0 to math.min(15, array.size(lCopy) - 1)
    lvl  = array.get(lCopy, i)
    w    = array.get(wCopy, i)

    array.push(topLvls , lvl)
    array.push(topPrbs , w)
    // absolute likelihood that price will *touch* this level inside hBars
    array.push(absProbs, f_probHit(lvl, src, sigmaH) * 100)

// recompute success rate off the final legs
successRate = f_cumeProb(topLvls, topPrbs, entryPrice, targetPrice, stopPrice)

// ════════════════════════════════
// STRATEGY ENTRY / EXIT (demo)
// ════════════════════════════════
longCond  = trendUp  and volBull  and src<lower and not outlier
shortCond = not trendUp and not volBull and src>upper and not outlier
if longCond
    strategy.entry("L",strategy.long)
if shortCond
    strategy.entry("S",strategy.short)

strategy.exit("XL","L", limit=mean, stop=lower-stDev)
strategy.exit("XS","S", limit=mean, stop=upper+stDev)

// ════════════════════════════════
// TABLE  (adds absolute-probability column)
// ════════════════════════════════
rowsHeader = 1
rowsStats  = 16  // Increased to 17 to accommodate R:R
rowsLadder = 16
tRows = rowsHeader + rowsStats + rowsLadder

// 9 columns: 0-3 stats, 4 = Abs %, 5-8 trade-plan
var table t = table.new(
     position.top_right,
     9,
     tRows,
     color.white,
     color.black,
     1)

// ───── header row ─────
if barstate.isfirst
    // stats / ladder part
    table.cell(t, 0, 0, "Metric"     , text_color = color.white, bgcolor = color.blue)
    table.cell(t, 1, 0, "Value"      , text_color = color.white, bgcolor = color.blue)
    table.cell(t, 2, 0, "Forecast"   , text_color = color.white, bgcolor = color.teal)
    table.cell(t, 3, 0, "Rank %"     , text_color = color.white, bgcolor = color.teal)
    table.cell(t, 4, 0, "Abs %"      , text_color = color.white, bgcolor = color.teal)  // NEW
    // trade-plan columns (shifted by +1)
    table.cell(t, 5, 0, "Entry"      , text_color = color.white, bgcolor = color.purple)
    table.cell(t, 6, 0, "Profit", text_color = color.white, bgcolor = color.purple)
    table.cell(t, 7, 0, "Stop-Loss"  , text_color = color.white, bgcolor = color.purple)
    table.cell(t, 8, 0, "Success %"  , text_color = color.white, bgcolor = color.purple)

// ───── helpers ─────
rowBG(_r) => _r % 2 ? color.new(color.gray, 92) : na
fNum(_x)  => str.tostring(_x, format.mintick)

// ───── stats rows 1-17 (NB-space keeps cols 2-4 wide) ─────
/// ───── stats rows 1–17 ─────
// ───── stats rows 1–17 ─────
fStat(_row, _lbl, _valStr) =>
    bg = rowBG(_row)

    // metric + value
    table.cell(t, 0, _row, _lbl    , bgcolor = bg)
    table.cell(t, 1, _row, _valStr , bgcolor = bg)

    // keep Forecast / Rank % / Abs % columns empty & aligned
    table.cell(t, 2, _row, ""      , bgcolor = bg)
    table.cell(t, 3, _row, ""      , bgcolor = bg)
    table.cell(t, 4, _row, ""      , bgcolor = bg)

fStat( 1, "Mean High"  , fNum(hi))
fStat( 2, "Mean Low"   , fNum(lo))
fStat( 3, "Mean HL"    , fNum(midHL))
fStat( 4, "Mean MA"    , fNum(mean))
fStat( 5, "Median"     , fNum(med))
fStat( 6, "Mode"       , fNum(mode))
fStat( 7, "Std Dev"    , fNum(stDev))
fStat( 8, "Upper SD"   , fNum(upper))
fStat( 9, "Lower SD"   , fNum(lower))
fStat(10, "Trend"      , trendUp  ? "↑ Up"   : "↓ Down")
fStat(11, "Vol Bias"   , volBull ? "Bullish" : "Bearish")
fStat(12, "Outlier"    , outlier ? "YES"     : "NO")
fStat(13, "Prob→Mode"  , str.tostring(math.round(f_probHit(mode ,src,stDev)*100)) + " %")
fStat(14, "Prob→Median", str.tostring(math.round(f_probHit(med  ,src,stDev)*100)) + " %")
fStat(15, "Prob→UpSD"  , str.tostring(math.round(f_probHit(upper,src,stDev)*100)) + " %")
fStat(16, "Prob→LoSD"  , str.tostring(math.round(f_probHit(lower,src,stDev)*100)) + " %")

/// ───── ladder rows (top-10 levels) ─────
ladderStart = rowsHeader   // == 1, immediately below the header

for i = 0 to rowsLadder - 1
    if i >= array.size(topLvls)
        break
    r = ladderStart + i    // rows 1,2,3… rather than 17,18,19…
    lvl   = array.get(topLvls , i)
    rankP = array.get(topPrbs , i)
    absP  = array.get(absProbs, i)
    isUp  = lvl > src

    bg = rowBG(r)
    table.cell(t, 2, r, str.tostring(lvl   , format.mintick) + (isUp ? "↑" : "↓"),
               text_color = isUp ? color.green : color.red, bgcolor = bg)
    table.cell(t, 3, r, str.tostring(math.round(rankP)) + " %", bgcolor = bg)
    table.cell(t, 4, r, str.tostring(math.round(absP )) + " %", bgcolor = bg)
//──────────────────────────────────────────────────────────────────
//  TRADE-PLAN SUPPORT FUNCTIONS  (must exist before we call them)
//──────────────────────────────────────────────────────────────────

// Return the index of the highest-probability ladder level that lies
//   • above current price  when _above=true   (bullish search)
//   • below current price  when _above=false  (bearish search)
// If no level matches, the function returns na.
f_bestLevel(_lvls, _prbs, _above) =>
    var int   bestIdx = na
    var float bestP   = 0.0
    for i = 0 to array.size(_lvls) - 1
        lvl = array.get(_lvls, i)
        p   = array.get(_prbs, i)
        if (_above ? lvl > src : lvl < src)
            if na(bestIdx) or p > bestP
                bestIdx := i
                bestP   := p
    bestIdx

// add the four headers once (already shifted in Step 2, but keep for safety)
if barstate.isfirst
    table.cell(t, 5, 0, "Entry"      , text_color = color.white, bgcolor = color.purple)
    table.cell(t, 6, 0, "Profit", text_color = color.white, bgcolor = color.purple)
    table.cell(t, 7, 0, "Stop-Loss"  , text_color = color.white, bgcolor = color.purple)
    table.cell(t, 8, 0, "Success %"  , text_color = color.white, bgcolor = color.purple)


// table rows to use
bullRow = 1      // bullish plan row
bearRow = 2      // bearish plan row



rowSuggest = rowsHeader  // show trade info right after header row

sucColor = successRate >= 70 ? color.green : successRate >= 50 ? color.orange : color.red

table.cell(t, 5, rowSuggest, str.tostring(entryPrice  , format.mintick))
table.cell(t, 6, rowSuggest, str.tostring(targetPrice , format.mintick))
table.cell(t, 7, rowSuggest, str.tostring(stopPrice   , format.mintick))
table.cell(t, 8, rowSuggest, str.tostring(math.round(successRate)) + " %", text_color = sucColor)


